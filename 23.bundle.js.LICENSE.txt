/* binding */

/* harmony export */

/* unused harmony exports Hooks, Lexer, Marked, Parser, Renderer, TextRenderer, Tokenizer, defaults, getDefaults, lexer, options, parse, parseInline, parser, setOptions, use, walkTokens */

/**
     * Expose Rules
     */

/**
     * Lexing/Compiling
     */

/**
     * Parse Inline Tokens
     */

/**
     * Parse Loop
     */

/**
     * Preprocessing
     */

/**
     * Process HTML after marked is finished
     */

/**
     * Process all tokens before walk tokens
     */

/**
     * Process markdown before marked
     */

/**
     * Provide function to parse tokens
     */

/**
     * Provide function to tokenize markdown
     */

/**
     * Run callback for every token
     */

/**
     * Static Lex Inline Method
     */

/**
     * Static Lex Method
     */

/**
     * Static Parse Inline Method
     */

/**
     * Static Parse Method
     */

/**
     * span level renderer
     */

/**
 * Block Lexer
 */

/**
 * Block-Level Grammar
 */

/**
 * Compiles markdown to HTML without enclosing `p` tag.
 *
 * @param src String of markdown source to be compiled
 * @param options Hash of options
 * @return String of compiled HTML
 */

/**
 * DO NOT EDIT THIS FILE
 * The code in this file is generated from files in ./src/
 */

/**
 * Expose
 */

/**
 * Gets the original marked default options.
 */

/**
 * Helpers
 */

/**
 * Parsing & Compiling
 */

/**
 * Remove trailing 'c's. Equivalent to str.replace(/c*$/, '').
 * /c*$/ is vulnerable to REDOS.
 *
 * @param str
 * @param c
 * @param invert Remove suffix of non-c chars instead. Default falsey.
 */

/**
 * Renderer
 */

/**
 * Run callback for every token
 */

/**
 * Sets the default options.
 *
 * @param options Hash of options
 */

/**
 * TextRenderer
 * returns only the textual part of the token
 */

/**
 * Tokenizer
 */

/**
 * Use Extension
 */

/**
 * marked v14.1.2 - a markdown parser
 * Copyright (c) 2011-2024, Christopher Jeffrey. (MIT Licensed)
 * https://github.com/markedjs/marked
 */

/***/

// ==-- Parse "addon" extensions --== //

// ==-- Parse "overwrite" extensions --== //

// ==-- Parse Hooks extensions --== //

// ==-- Parse WalkTokens extensions --== //

// @ts-expect-error cannot type hook function dynamically

// @ts-expect-error cannot type tokenizer function dynamically

// An indented code block cannot interrupt a paragraph.

// Check for task list items

// Check if current bullet point can start a new List Item

// Check if current line is blank

// Check if following lines should be included in List Item

// Check if list should be loose

// Child tokens to be visited by walkTokens

// Clip maskedSrc to same section of string as src (move to lexer?)

// CommonMark Emphasis Rules 9-10

// CommonMark requires space before trailing #s

// Create 'strong' if smallest delimiter has even char count. **a***

// Create `em` if smallest delimiter has odd char count. *a***

// Dedent if possible

// Do not consume newlines at end of final item. Alternatively, make itemRegex *start* with any newlines to simplify/speed up endsWithBlankLine logic

// End list if bullet was actually HR (possibly move into itemRegex?)

// End list item if found code fences

// End list item if found start of html block

// End list item if found start of new bullet

// End list item if found start of new heading

// Find first non-space char

// First/last cell in a row cannot be empty if it has no leading/trailing pipe

// Function to check for start of token

// Get next list item

// Haven't found enough closing delimiters

// Horizontal rule found

// If the previous item ended with a blank line, the list is loose

// Item child tokens handled here at end because we needed to have the final item to trim it first

// Items begin with at most one blank line

// Length of suffix matching the invert condition.

// Mask out escaped characters

// Mask out other blocks

// Mask out reflinks

// Re-align to follow commonmark nesting rules

// Remove extra characters. *a*** -> *a*

// Renderer extensions

// Replace extension with func to run new extension but fall back if false

// Replace renderer with func to run extension, but fall back if false

// Replace tokenizer with func to run extension, but fall back if false

// Run any renderer extensions

// Set all items to loose if list is loose

// Step left until we fail to match the invert condition.

// String with links masked to avoid interference with em and strong

// TokenList cannot be created in one go

// Tokenizer Extensions

// Track prevChar before string of ____ started

// Treat indented code blocks (> 4 spaces) as having only 1 indent

// _ can't be between two alphanumerics. \p{L}\p{N} includes non-english alphabet/numbers as well

// autolink

// before it to distinguish it from an escaped pipe

// blockquote

// blockquote continuation cannot be preceded by a code block

// br

// char length can be >1 for unicode characters;

// code

// commonmark requires matching angle brackets

// copy options to new object

// def

// del (gfm)

// delimiter row must have a pipe (|) or colon (:) otherwise it is a setext heading

// do extended autolink path validation

// em & strong

// ending angle bracket cannot be escaped

// ensure that every cell-delimiting pipe has a space

// escape

// extensions

// fences

// fences not supported

// find closing parenthesis

// found another Left Delim

// get lines up to a continuation

// header

// heading

// hr

// html

// if there is no continuation then we are done

// if there's a single \n as a spacer, it's terminating the last line,

// ignore options and block properties

// ignore options property

// ignore options, rules, and lexer properties

// include continuation in nested blockquote

// include continuation in nested list

// indented code block

// leading or trailing whitespace is ignored per the gfm spec

// lheading

// link

// list

// merge paragraphs if this is a continuation

// newline

// no need for block level renderers

// not enough indentation

// only used for GFM url

// paragraph continuation unless last line was a different block level element

// parse blockquote lines as top level tokens

// pedantic allows starting angle bracket without ending angle bracket

// prevent inlineText consuming extensions by clipping 'src' to extension start

// prevent paragraph consuming extensions by clipping 'src' to extension start

// reflink, nolink

// remove trailing #s

// set async to true if it was set to true before

// set by the lexer

// set by the parser

// skip single * in __abc*abc__

// so move it there so that we don't get unnecessary paragraph tags

// split pedantic href and title

// table (gfm)

// tag

// text

// throw error if an extension set async to true but parse was called with async: false

// throw error in case of non string input

// top-level paragraph

// unicode Regex counts emoji as 1 char; spread into array for proper count (used multiple times below)

// url (gfm)
