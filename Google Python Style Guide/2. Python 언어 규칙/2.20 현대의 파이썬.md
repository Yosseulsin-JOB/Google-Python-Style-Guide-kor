<a id="s2.20-modern-python"></a>

### 2.20 Modern Python : from, \_\_future\_\_, imports

- New language version semantic changes may be gated behind a special future import to enable them on a per-file basis within earlier runtimes.

<a id="s2.20.1-definition"></a>

#### 2.20.1 정의

- Being able to turn on some of the more modern features via `from __future__import` statements allows early use of features from expected future Python versions.

<a id="s2.20.2-pros"></a>

#### 2.20.2 장점

- This has proven to make runtime version upgrades smoother as changes can be made
  on a per-file basis while declaring compatibility and preventing regressions
  within those files. Modern code is more maintainable as it is less likely to
  accumulate technical debt that will be problematic during future runtime
  upgrades.

<a id="s2.20.3-cons"></a>

#### 2.20.3 단점

- Such code may not work on very old interpreter versions prior to the introduction of the needed future statement. The need for this is more common in projects supporting an extremely wide variety of environments.

<a id="s2.20.4-decision"></a>

#### 2.20.4 결론

##### from \_\_future\_\_ imports

- `from __future__ import` 형태를 사용하는 것이 바람직합니다.
- It allows a given source file to start using more modern Python syntax features today.
- Once you no longer need to run on a version where the features are hidden behind a `__future__` import, feel free to remove those lines.

In code that may execute on versions as old as 3.5 rather than >= 3.7, import:

```python
from __future__ import generator_stop
```

For legacy code with the burden of continuing to support 2.7, import:

```python
from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
```

- For more information read the [Python future statement definitions](https://docs.python.org/3/library/__future__.html) documentation.

- Please don't remove these imports until you are confident the code is only ever used in a sufficiently modern environment.
- Even if you do not currently use the feature a specific future import enables in your code today, keeping it in place in the file prevents later modifications of the code from inadvertently depending on the older behavior.

- Use other `from __future__` import statements as you see fit.
- We did not include `unicode_literals` in our recommendations for 2.7 as it was not a clear win due to implicit default codec conversion consequences it introduced in many places within 2.7.
- Most dual-version 2-and-3 code was better off with explicit use of `b''` and `u''` bytes and unicode string literals where necessary.

##### six, future 그리고 past 라이브러리

- When your project still needs to support use under both Python 2 and 3, use the [six](https://pypi.org/project/six/), [future](https://pypi.org/project/future/), and
  [past](https://pypi.org/project/past/) libraries as you see fit. They exist to make your code cleaner and life easier.
